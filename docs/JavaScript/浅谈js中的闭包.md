---
title: 浅谈js中的闭包
createTime: 2025/06/25 16:41:37
permalink: /article/eagyikza/
tags:
  - JavaScript
  - 闭包
excerpt: 从定义、特性、形成条件、作用、优缺点及应用场景等多个方面谈谈闭包。

---
## 什么是闭包？

闭包的定义可以从不同角度描述：

::: warning **基本定义**  

闭包是指==一个函数能够记住其定义时的作用域，即使在函数执行完毕后，其作用域依然存在==。

具体来说，闭包是由函数和其外部环境（即作用域）组成的组合。

:::

::: tip **通俗理解**
   当一个函数“记住”了它在创建时的作用域环境，并能在它执行时继续访问这个作用域中的变量时，就形成了闭包。
:::

## 闭包的特性

闭包有以下几个显著特性：

1. ==**作用域链的向上查找**=={.note}  

   闭包会通过作用域链访问其外部函数的变量。即使外部函数已经执行完毕，闭包依然能够访问这些变量。

2. ==**延长变量的生命周期**=={.note}

   通常情况下，函数执行完毕后，其作用域会被销毁。但闭包会将外部函数的作用域保存在内存中，延长了这些变量的生命周期。

3. ==**函数嵌套**=={.note}  

   闭包的本质是函数嵌套，内部函数可以访问外部函数的变量，而外部函数无法访问内部函数的变量。

4. ==**数据存储容器**=={.note}

   闭包可以看作是一种存储数据的容器，类似于 `Map` 或 `Set`，其内部以 key-value 的形式存储变量。

5. ==**保护作用**=={.note}  

   闭包可以隔离数据，将外部访问限制在特定的范围内，从而实现对变量的保护。


## 闭包的形成条件

闭包的形成需要满足以下两个条件：

1. **<Badge text="函数嵌套" type="warning"/>**

2. **<Badge text="内部函数引用外部函数的变量" type="tip"/>**

代码示例：

```ts
function outerFunction() {
  let count = 0; // 外部函数的局部变量

  function innerFunction() { /*[!code highlight]*/
      /*[!code highlight]*/
    count++; // 内部函数引用了外部函数的变量
    console.log(count);/*[!code highlight]*/
  }/*[!code highlight]*/

  return innerFunction; // 将内部函数返回，形成闭包
}

const closure = outerFunction(); // 执行外部函数，获取内部函数的引用
closure(); // 输出 1
closure(); // 输出 2
closure(); // 输出 3
```

## 闭包的作用

闭包在 JavaScript 中的作用主要体现在以下两个方面：

1. ==**保护（隔离）**=={.important}

   闭包可以***保护函数内部的变量不受外界干扰***，形成一个私有的作用域。外部无法直接修改这些变量，只能通过闭包提供的接口进行操作。 

   例如：在模块化开发中，闭包可以用来封装私有变量和方法，避免全局变量污染。

2. ==**保存（记忆）**=={.important} 

   闭包可以***延长变量的生命周期***，将某些变量保存在内存中，供后续使用。这种特性非常适合需要持久化数据的场景。


## 闭包的优点

1. ==**延长局部变量的生命周期**=={.tip}

   通常情况下，函数运行结束后其局部变量会被销毁。但 **_通过闭包，这些变量可以长期存储在内存中_**。

2. ==**数据封装**=={.tip}  

   **_闭包实现了对变量的私有化保护_**，可以有效避免全局变量污染，使代码更加模块化和安全。

3. ==**简化逻辑**=={.tip}  

   闭包可以通过 **_保存中间状态_**，简化复杂逻辑的实现。例如，事件处理函数可以记住初始状态，避免重复计算。

4. ==**增强函数的灵活性**=={.tip}  

   闭包使得函数可以 **_动态生成不同的逻辑_**，从而提高代码的复用性和可维护性。

## 闭包的缺点

1. ==**内存占用**=={.caution}  

   由于闭包会保存外部函数的作用域，可能导致内存占用增加。如果闭包被频繁创建或者不及时释放，**_可能会引发内存泄漏_**。

2. ==**性能开销**=={.caution} 

   JavaScript 的垃圾回收机制通常会释放不再使用的变量，但 **_闭包会延长变量的生命周期_**，增加了垃圾回收的负担。

3. ==**代码复杂性增加**=={.caution}  

   过度使用闭包可能导致代码的可读性和维护性下降，_**尤其是在嵌套过深时**_。


## 闭包的应用场景

闭包在 JavaScript 的开发中应用非常广泛，以下是一些常见的场景：

1. ==**事件处理**==  

   闭包可以存储事件处理函数执行时的上下文信息。例如，在绑定事件时，闭包可以记住初始状态，从而实现动态行为。

2. ==**回调函数**==  

   在异步操作中，例如定时器、网络请求、Promise 等，闭包可以保存函数执行时的状态和变量。

3. ==**数据封装**== 

   闭包可以用来创建模块化代码，通过定义私有变量和方法，限制外部对数据的直接访问。例如，计数器、缓存等功能常通过闭包实现。

4. ==**模拟块级作用域**== 

   在没有 `let` 和 `const` 的时代，通过闭包可以模拟块级作用域，避免变量污染全局作用域。

5. ==**函数柯里化**==

   _**（什么是函数柯里化？ → [js中的函数柯里化](/JavaScript/js中的函数柯里化.md)）**_

   闭包是实现柯里化的关键。柯里化函数通过闭包保存部分参数，从而生成新的函数。

6. ==**惰性函数**==  

   闭包可以用来创建惰性函数，在需要时延迟执行代码，从而提高性能。

## 闭包的注意事项
::: warning
**合理使用闭包**  

   虽然闭包功能强大，但滥用闭包可能导致代码复杂度增加或性能问题。在性能敏感的场景中，应谨慎使用闭包。

**避免内存泄漏**

   闭包会导致外部函数的作用域无法被释放，因此需要避免不必要的闭包引用。例如，不要在全局变量中保存闭包函数。

**调试困难**  
 
   由于闭包会保留创建时的作用域，调试时可能难以直观地理解变量的来源。因此，代码中应适当添加注释，帮助理解闭包的行为。
:::

## 总结

闭包是 JavaScript 中非常重要的特性，它通过保存外部函数的作用域，实现了对变量的保护和保存。闭包的应用场景广泛，从事件处理到数据封装，从函数柯里化到模块化开发，几乎无处不在。然而，闭包的使用也需要注意内存管理和代码复杂性的控制。掌握闭包的原理和应用技巧，是成为高级 JavaScript 开发者的必备技能。