import{_ as a,c as e,a as r,o}from"./app-C5hizgfq.js";const i={};function n(s,t){return o(),e("div",null,t[0]||(t[0]=[r('<h2 id="宏任务" tabindex="-1"><a class="header-anchor" href="#宏任务"><span>宏任务</span></a></h2><h3 id="宏任务的定义" tabindex="-1"><a class="header-anchor" href="#宏任务的定义"><span>宏任务的定义</span></a></h3><p><mark class="tip"><strong>宏任务</strong>（Macrotask）是 JavaScript 运行中被调度执行的大颗粒度任务。</mark></p><p>页面中的大部分操作都属于宏任务，例如：</p><ul><li>页面渲染事件（解析 DOM、计算布局、绘制）。</li><li>用户交互事件（鼠标点击、滚动、缩放等）。</li><li>JavaScript 脚本执行。</li><li>网络请求完成、文件读写完成事件。</li></ul><p>宏任务通过事件循环（Event Loop）机制进行调度。浏览器会维护多个消息队列，如普通消息队列和延迟执行队列，主线程会通过持续循环从这些队列中取出任务并执行。</p><h3 id="宏任务的执行流程" tabindex="-1"><a class="header-anchor" href="#宏任务的执行流程"><span>宏任务的执行流程</span></a></h3><p>根据 WHATWG 规范，宏任务的执行流程可简化为以下步骤：</p><ol><li>从多个消息队列中选取最早的任务（<code>oldestTask</code>）。</li><li>记录任务的开始时间，将其设置为当前正在执行的任务。</li><li>执行该任务，并将其从队列中移除。</li><li>统计任务执行时长，继续下一任务。</li></ol><p>这种执行方式确保了任务的顺序性与稳定性，但也因此存在一定的局限性。</p><h3 id="宏任务的局限性" tabindex="-1"><a class="header-anchor" href="#宏任务的局限性"><span>宏任务的局限性</span></a></h3><p>由于消息队列的任务由系统调度，JavaScript 无法细粒度地控制任务的插入顺序。因此，宏任务的执行时间间隔难以精确控制。例如：</p><ol><li>在设置多个 <code>setTimeout</code> 回调时，系统可能在回调任务间插入渲染任务等系统级任务。</li><li>如果插入的任务执行时间过长，会导致后续任务的时延增加，影响整体性能。</li></ol><p>宏任务的这种粗时间颗粒度特性，限制了其在高实时性场景中的应用。</p><h2 id="微任务" tabindex="-1"><a class="header-anchor" href="#微任务"><span>微任务</span></a></h2><h3 id="微任务的定义" tabindex="-1"><a class="header-anchor" href="#微任务的定义"><span>微任务的定义</span></a></h3><p><mark class="tip"><strong>微任务</strong>（Microtask）是运行于 JavaScript 引擎中的细粒度异步任务。它的执行时机是在 <strong>当前宏任务结束后、下一个宏任务开始前</strong>。</mark></p><p>微任务的设计初衷是为了解决宏任务时间颗粒度过大的问题。通过微任务，可以更高效地处理需要即时响应的任务。微任务的典型应用包括：</p><ul><li><code>Promise</code> 的回调。</li><li><code>MutationObserver</code> 监听 DOM 变化。</li></ul><h3 id="微任务的执行机制" tabindex="-1"><a class="header-anchor" href="#微任务的执行机制"><span>微任务的执行机制</span></a></h3><p>每个宏任务执行时，会创建一个属于自己的 <strong>微任务队列</strong>。微任务队列的执行流程如下：</p><ol><li>在当前宏任务执行完成后，检查微任务队列。</li><li>按照顺序执行队列中的所有微任务。</li><li>如果在执行微任务时产生了新的微任务，则将其立即加入队列，并继续执行，直到队列清空。</li></ol><p>这意味着微任务的执行优先级高于后续的宏任务。</p><h3 id="微任务的来源" tabindex="-1"><a class="header-anchor" href="#微任务的来源"><span>微任务的来源</span></a></h3><p>微任务主要通过以下两种方式产生：</p><ol><li><p><strong><code>Promise</code></strong><br> 使用 <code>Promise.resolve()</code> 或 <code>Promise.reject()</code> 会立即生成一个微任务，并加入当前的微任务队列。</p></li><li><p><strong><code>MutationObserver</code></strong><br> 通过监听 DOM 节点的变化，当节点被修改时，会生成一个微任务，记录 DOM 的变化信息。</p></li></ol><h2 id="宏任务与微任务的区别" tabindex="-1"><a class="header-anchor" href="#宏任务与微任务的区别"><span>宏任务与微任务的区别</span></a></h2><table><thead><tr><th>特性</th><th>宏任务（Macrotask）</th><th>微任务（Microtask）</th></tr></thead><tbody><tr><td><strong>来源</strong></td><td>渲染事件、网络请求、用户交互、<code>setTimeout</code></td><td><code>Promise</code>、<code>MutationObserver</code></td></tr><tr><td><strong>执行时机</strong></td><td>主线程从消息队列中取出任务时执行</td><td>当前宏任务结束后、下一个宏任务开始前</td></tr><tr><td><strong>执行优先级</strong></td><td>低</td><td>高</td></tr><tr><td><strong>时间精度</strong></td><td>粗</td><td>精确</td></tr></tbody></table><h2 id="宏任务与微任务的关系" tabindex="-1"><a class="header-anchor" href="#宏任务与微任务的关系"><span>宏任务与微任务的关系</span></a></h2><p>每一个宏任务都绑定了一个微任务队列。当一个宏任务执行完成时，JavaScript 引擎会检查并执行该任务中产生的所有微任务。只有微任务队列被清空后，才会开始执行下一个宏任务。</p><p>这种机制保证了微任务的高优先级，同时也可能带来一定的问题。例如，在一个宏任务中，如果微任务的数量过多或执行时间过长，可能会显著延长该宏任务的执行时间，从而影响页面的响应性能。</p><h2 id="微任务的优势" tabindex="-1"><a class="header-anchor" href="#微任务的优势"><span>微任务的优势</span></a></h2><ol><li><p><strong>高实时性</strong><br> 微任务的执行时机非常精确，能够在当前宏任务结束后立即执行，适合对时间精度要求高的场景。</p></li><li><p><strong>减少性能开销</strong><br> 微任务在当前宏任务内完成，不需要切换到新的事件循环，能够有效减少性能开销。</p></li><li><p><strong>灵活性强</strong><br> 微任务的执行机制更符合异步任务的需求，广泛应用于现代开发中。</p></li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>宏任务与微任务是 JavaScript 异步机制的重要组成部分。宏任务适合处理大颗粒度的任务调度，而微任务则通过更高优先级、更精确的执行时机补充了宏任务的不足。在实际开发中，合理利用宏任务与微任务的特性，可以编写出更加高效、现代化的代码。</p><p>了解二者的底层原理，不仅有助于你读懂复杂的代码逻辑，还能帮助你写出性能更优的程序。在未来，随着 JavaScript 生态的不断发展，微任务的应用场景和重要性仍会持续增加。</p>',36)]))}const c=a(i,[["render",n]]),d=JSON.parse('{"path":"/article/e3tjrbp1/","title":"宏任务与微任务","lang":"zh-CN","frontmatter":{"title":"宏任务与微任务","createTime":"2025/06/24 17:19:42","permalink":"/article/e3tjrbp1/","tags":["宏任务","微任务"],"excerpt":"随着应用场景的复杂化，任务调度机制显得尤为重要。本篇文章将详细介绍一下宏任务与微任务的知识。","description":"宏任务 宏任务的定义 宏任务（Macrotask）是 JavaScript 运行中被调度执行的大颗粒度任务。 页面中的大部分操作都属于宏任务，例如： 页面渲染事件（解析 DOM、计算布局、绘制）。 用户交互事件（鼠标点击、滚动、缩放等）。 JavaScript 脚本执行。 网络请求完成、文件读写完成事件。 宏任务通过事件循环（Event Loop）机制...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"宏任务与微任务\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-01T16:52:49.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://try-catch.life/article/e3tjrbp1/"}],["meta",{"property":"og:site_name","content":"码不停蹄"}],["meta",{"property":"og:title","content":"宏任务与微任务"}],["meta",{"property":"og:description","content":"宏任务 宏任务的定义 宏任务（Macrotask）是 JavaScript 运行中被调度执行的大颗粒度任务。 页面中的大部分操作都属于宏任务，例如： 页面渲染事件（解析 DOM、计算布局、绘制）。 用户交互事件（鼠标点击、滚动、缩放等）。 JavaScript 脚本执行。 网络请求完成、文件读写完成事件。 宏任务通过事件循环（Event Loop）机制..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-01T16:52:49.000Z"}],["meta",{"property":"article:tag","content":"微任务"}],["meta",{"property":"article:tag","content":"宏任务"}],["meta",{"property":"article:modified_time","content":"2025-07-01T16:52:49.000Z"}]]},"readingTime":{"minutes":4.67,"words":1400},"git":{"createdTime":1750760943000,"updatedTime":1751388769000,"contributors":[{"name":"221250108","username":"221250108","email":"221250108@smail.nju.edu.cn","commits":6,"avatar":"https://avatars.githubusercontent.com/221250108?v=4","url":"https://github.com/221250108"}]},"autoDesc":true,"filePathRelative":"前端开发/宏任务与微任务.md","headers":[],"categoryList":[{"id":"0ffed7","sort":10000,"name":"前端开发"}]}');export{c as comp,d as data};
