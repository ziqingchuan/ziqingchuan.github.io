import{_ as i,c as t,a,o as e}from"./app-DUi_DKrR.js";const n={};function d(h,s){return e(),t("div",null,[...s[0]||(s[0]=[a(`<h2 id="一、响应式系统重构-从-object-defineproperty-到-proxy" tabindex="-1"><a class="header-anchor" href="#一、响应式系统重构-从-object-defineproperty-到-proxy"><span>一、响应式系统重构：从 <code>Object.defineProperty</code> 到 <code>Proxy</code></span></a></h2><table><thead><tr><th>特性</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td>核心 API</td><td><code>Object.defineProperty</code></td><td><code>Proxy</code></td></tr><tr><td>监听范围</td><td>仅能监听对象属性的读写</td><td>可监听对象新增/删除属性、数组索引/长度变化</td></tr><tr><td>初始化性能</td><td>需递归遍历对象所有属性</td><td>懒代理（访问时才递归子属性）</td></tr><tr><td>数组处理</td><td>需重写数组原型方法（如 <code>push</code>、<code>splice</code>）</td><td>原生数组方法直接触发响应</td></tr></tbody></table><p><strong>核心优势</strong>：<br> Vue3 的 <code>Proxy</code> 实现解决了 Vue2 中著名的&quot;响应式遗漏&quot;问题，例如：</p><ul><li>无需再用 <code>Vue.set(obj, key, value)</code> 新增响应式属性</li><li>直接修改数组索引（<code>arr[0] = 1</code>）或长度（<code>arr.length = 0</code>）会触发更新</li></ul><h2 id="二、组件写法-options-api-与-composition-api" tabindex="-1"><a class="header-anchor" href="#二、组件写法-options-api-与-composition-api"><span>二、组件写法：Options API 与 Composition API</span></a></h2><h3 id="vue2-options-api" tabindex="-1"><a class="header-anchor" href="#vue2-options-api"><span>Vue2：Options API</span></a></h3><p>通过固定选项（<code>data</code>、<code>methods</code>、<code>computed</code> 等）组织代码，逻辑分散在不同选项中：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">export</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> default</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  data</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;"> count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  },</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">  methods</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    increment</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  },</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">  computed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    doubleCount</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> return</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="vue3-composition-api-推荐" tabindex="-1"><a class="header-anchor" href="#vue3-composition-api-推荐"><span>Vue3：Composition API（推荐）</span></a></h3><p>通过 <code>setup</code> 函数或 <code>&lt;script setup&gt;</code> 语法，按功能逻辑组织代码，解决&quot;关注点分散&quot;问题：</p><div class="language-vue line-numbers-mode" data-highlighter="shiki" data-ext="vue" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-vue"><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> setup</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">import</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> ref</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> computed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">vue</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 计数器相关逻辑（可抽离为独立函数）</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ref</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> increment</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> ()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">value</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> doubleCount</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> computed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">value</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="三、生命周期钩子变化" tabindex="-1"><a class="header-anchor" href="#三、生命周期钩子变化"><span>三、生命周期钩子变化</span></a></h2><p>Vue3 保留了大部分生命周期概念，但命名和使用方式有调整，且与 Composition API 配合更紧密：</p><table><thead><tr><th>Vue2 选项式</th><th>Vue3 组合式（setup 中）</th><th>说明</th></tr></thead><tbody><tr><td>beforeCreate</td><td>无（setup 执行时等效）</td><td>初始化前</td></tr><tr><td>created</td><td>无（setup 执行时等效）</td><td>初始化后</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td><td>挂载前</td></tr><tr><td>mounted</td><td>onMounted</td><td>挂载后</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td><td>更新前</td></tr><tr><td>updated</td><td>onUpdated</td><td>更新后</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount</td><td>卸载前（命名更准确）</td></tr><tr><td>destroyed</td><td>onUnmounted</td><td>卸载后（命名更准确）</td></tr></tbody></table><h2 id="四、模板语法增强" tabindex="-1"><a class="header-anchor" href="#四、模板语法增强"><span>四、模板语法增强</span></a></h2><h3 id="_4-1-多根节点支持-fragment" tabindex="-1"><a class="header-anchor" href="#_4-1-多根节点支持-fragment"><span>4.1 多根节点支持（Fragment）</span></a></h3><p>Vue2 模板要求<em><strong>单一根节点</strong></em>，Vue3 <em><strong>支持多根节点</strong></em>，无需额外包裹。</p><h3 id="_4-2-指令与修饰符变化" tabindex="-1"><a class="header-anchor" href="#_4-2-指令与修饰符变化"><span>4.2 指令与修饰符变化</span></a></h3><ul><li><p><code>v-model</code> 重构：<mark>Vue3 统一了组件内外双向绑定逻辑，替代 Vue2 的 <code>.sync</code> 修饰符</mark></p></li><li><p><code>v-if</code> 与 <code>v-for</code> 优先级：<mark>Vue3 中 <code>v-if</code> 优先级高于 <code>v-for</code>（避免逻辑混淆）</mark></p></li><li><p>新增 <code>v-memo</code> 指令：缓存模板片段，优化高频更新场景</p></li></ul><h2 id="五、性能优化" tabindex="-1"><a class="header-anchor" href="#五、性能优化"><span>五、性能优化</span></a></h2><ol><li><p><strong>打包体积减小</strong>：<br> Vue3 移除了部分不常用 API（如 filter），通过 Tree-Shaking 减少打包体积（约减小 40%）。</p></li><li><p><strong>渲染性能提升</strong>：</p><ul><li>引入虚拟 DOM 重写，减少不必要的节点对比</li><li>静态节点提升（hoistStatic）：将静态内容编译为常量，避免重复创建</li><li>事件缓存（cacheHandlers）：相同事件处理器复用，减少重新绑定</li></ul></li><li><p><strong>运行时优化</strong>：</p><ul><li>响应式系统的懒代理机制，初始化性能更好</li><li>组件更新粒度更精确，减少无关组件重渲染</li></ul></li></ol><h2 id="六、其他重要差异" tabindex="-1"><a class="header-anchor" href="#六、其他重要差异"><span>六、其他重要差异</span></a></h2><table><thead><tr><th>特性</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td>入口文件</td><td><code>new Vue()</code> 创建实例</td><td><code>createApp()</code> 创建应用</td></tr><tr><td>全局 API</td><td>挂载在 Vue 构造函数上（如 <code>Vue.use</code>）</td><td>需从 vue 导入（如 <code>app.use</code>）</td></tr><tr><td>过滤器（<code>filter</code>）</td><td>支持</td><td>移除（推荐用计算属性替代）</td></tr><tr><td>组件 <code>emits</code></td><td>无明确声明（通过 <code>this.$emit</code>）</td><td>需在 <code>emits</code> 选项中声明（更规范）</td></tr><tr><td>插槽语法</td><td>slot 属性 + <code>slot-scope</code></td><td><code>v-slot</code> 指令（简化为 #）</td></tr></tbody></table>`,23)])])}const l=i(n,[["render",d]]),r=JSON.parse('{"path":"/article/f5d1n6ab/","title":"Vue2与Vue3的区别","lang":"zh-CN","frontmatter":{"title":"Vue2与Vue3的区别","createTime":"2025/06/30 21:32:17","permalink":"/article/f5d1n6ab/","tags":["Vue"],"excerpt":"淘天一面问到这个，说的有点草率，这次梳理一下具体区别。","description":"一、响应式系统重构：从 Object.defineProperty 到 Proxy 核心优势： Vue3 的 Proxy 实现解决了 Vue2 中著名的\\"响应式遗漏\\"问题，例如： 无需再用 Vue.set(obj, key, value) 新增响应式属性 直接修改数组索引（arr[0] = 1）或长度（arr.length = 0）会触发更新 二、组件...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue2与Vue3的区别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-02T11:56:44.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://try-catch.life/article/f5d1n6ab/"}],["meta",{"property":"og:site_name","content":"码不停蹄"}],["meta",{"property":"og:title","content":"Vue2与Vue3的区别"}],["meta",{"property":"og:description","content":"一、响应式系统重构：从 Object.defineProperty 到 Proxy 核心优势： Vue3 的 Proxy 实现解决了 Vue2 中著名的\\"响应式遗漏\\"问题，例如： 无需再用 Vue.set(obj, key, value) 新增响应式属性 直接修改数组索引（arr[0] = 1）或长度（arr.length = 0）会触发更新 二、组件..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-02T11:56:44.000Z"}],["meta",{"property":"article:tag","content":"Vue"}],["meta",{"property":"article:modified_time","content":"2025-07-02T11:56:44.000Z"}]]},"readingTime":{"minutes":2.75,"words":826},"git":{"createdTime":1751292296000,"updatedTime":1751457404000,"contributors":[{"name":"221250108","username":"221250108","email":"221250108@smail.nju.edu.cn","commits":4,"avatar":"https://avatars.githubusercontent.com/221250108?v=4","url":"https://github.com/221250108"}]},"autoDesc":true,"filePathRelative":"Vue/Vue2与Vue3的区别.md","headers":[],"categoryList":[{"id":"2d8ec5","sort":10001,"name":"Vue"}]}');export{l as comp,r as data};
