import{_ as n,c as s,a,b as r,d as o,e as i,w as c,r as d,o as l}from"./app-DVkErQMr.js";const p={};function m(h,e){const t=d("RouteLink");return l(),s("div",null,[e[2]||(e[2]=a('<h2 id="跨域的原理" tabindex="-1"><a class="header-anchor" href="#跨域的原理"><span>跨域的原理</span></a></h2><h3 id="什么是跨域" tabindex="-1"><a class="header-anchor" href="#什么是跨域"><span>什么是跨域？</span></a></h3><div class="hint-container tip"><p class="hint-container-title">跨域</p><p>跨域指的是当<mark class="note">一个网页的 JavaScript 脚本请求另一个域的资源时，浏览器出于安全考虑而阻止这种行为。</mark>这种情况通常会发生在以下情况下：</p><ul><li>协议不同，例如 HTTP 和 HTTPS</li><li>域名不同，例如 <code>example.com</code> 和 <code>example.net</code></li><li>端口不同，例如 <code>example.com:80</code> 和 <code>example.com:3000</code></li></ul></div><h3 id="同源策略" tabindex="-1"><a class="header-anchor" href="#同源策略"><span>同源策略</span></a></h3><div class="hint-container tip"><p class="hint-container-title">定义</p><p>同源策略是浏览器的一项安全机制，旨在防止恶意脚本窃取用户信息。具体来说，<mark class="note">同源意味着协议、主机和端口必须完全相同。任何不同之处都会导致浏览器将请求视为跨域请求。</mark></p></div><h2 id="跨域的解决方案" tabindex="-1"><a class="header-anchor" href="#跨域的解决方案"><span>跨域的解决方案</span></a></h2><h3 id="_1-jsonp" tabindex="-1"><a class="header-anchor" href="#_1-jsonp"><span><mark>1. JSONP</mark></span></a></h3><p><code>JSONP</code>（JSON with Padding）是最早的一种解决跨域请求的方法，它利用了 <code>&lt;script&gt;</code> 标签的跨域特性。<strong><em>通过动态创建一个 <code>&lt;script&gt;</code> 标签，将 <code>src</code> 设置为跨域的接口地址，并在请求中传递一个回调函数的名称，服务器会返回一个调用该函数的 JavaScript 代码。这样可以实现跨域的数据获取。</em></strong></p><p><strong>优缺点：</strong></p><ul><li>优点：易于使用，兼容旧版浏览器。</li><li>缺点： <ul><li>仅支持 <code>GET</code> 请求。</li><li>需要后端配合返回特定格式的数据。</li></ul></li></ul><h3 id="_2-cors-跨域资源共享" tabindex="-1"><a class="header-anchor" href="#_2-cors-跨域资源共享"><span><mark>2. CORS（跨域资源共享）</mark></span></a></h3><p><code>CORS</code> 是现代浏览器支持的一种机制，它允许服务器在响应中设置跨域请求的允许条件。<strong><em>服务器通过设置 <code>Access-Control-Allow-Origin</code> 响应头，声明允许哪些域进行跨域请求。</em></strong></p><p><strong>优缺点：</strong></p><ul><li>优点：支持多种 HTTP 方法（如 <code>POST</code>、<code>PUT</code>、<code>DELETE</code>）。</li><li>缺点：相对复杂，需要后端和前端的合作。</li></ul><h3 id="_3-代理服务器" tabindex="-1"><a class="header-anchor" href="#_3-代理服务器"><span><mark>3. 代理服务器</mark></span></a></h3><p>在开发过程中，<strong><em>使用代理服务器是一种常见的解决方案</em></strong>。代理可以通过设置相应的网络配置，允许前端开发环境与后端接口之间进行有效通信。例如，在 <code>webpack</code> 的开发服务器中，可以配置 <code>proxy</code> 选项，将请求转发到后端服务器。生产环境中，使用 nginx 等反向代理服务器同样可以轻松处理跨域请求。</p><blockquote><p>使用vercel部署时，通过配置api/proxy.js文件，可以实现跨域请求。</p></blockquote><blockquote><p>开发figma插件时，通过在manifest.json文件中配置networkAccess选项的allowedDomains属性，可以实现跨域请求。</p></blockquote><h3 id="_4-window-postmessage" tabindex="-1"><a class="header-anchor" href="#_4-window-postmessage"><span><mark>4. window.postMessage()</mark></span></a></h3><p><code>window.postMessage()</code> 是 HTML5 中新增的一个特性，允许不同源的窗口或 iframe 之间进行安全的消息传递。这提供了一种灵活的方法来处理复杂的跨域交互。</p><blockquote><p>好未来实习期间，考试报告升级B端点击下载C端的报告时，使用该方法获取C端的考试报告的Canvas数据，实现了跨域数据共享。</p></blockquote><h3 id="_5-document-domain" tabindex="-1"><a class="header-anchor" href="#_5-document-domain"><span><mark>5. document.domain</mark></span></a></h3><p>当子域名不同但基础域名相同时，可以通过 <strong><em>设置 <code>document.domain</code> 实现跨域数据共享</em></strong>。例如，将 <code>document.domain</code> 设置为 <code>example.com</code> 可以使所有子域之间共享。</p><h3 id="_6-window-name" tabindex="-1"><a class="header-anchor" href="#_6-window-name"><span><mark>6. window.name</mark></span></a></h3><p>利用 <code>window.name</code> 属性可以在不同域名间共享数据，因其在页面跳转时不受同源政策的限制。<strong><em>通过使用一个中转页面，可以将数据存储在 <code>window.name</code> 中，然后再从目标页面读取这些数据</em></strong>。</p><h2 id="跨域相关的存储机制" tabindex="-1"><a class="header-anchor" href="#跨域相关的存储机制"><span>跨域相关的存储机制</span></a></h2><p>了解不同的客户端存储机制，如 <code>Cookie</code>、<code>sessionStorage</code> 和 <code>localStorage</code>，有助于在跨域请求中保存用户状态。</p>',27)),r("p",null,[e[1]||(e[1]=o("关于Cookie和Session的知识：",-1)),i(t,{to:"/HTTP/Cookie%E4%B8%8ESession.html"},{default:c(()=>e[0]||(e[0]=[o("点击跳转",-1)])),_:1,__:[0]})]),e[3]||(e[3]=a('<h3 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie"><span><mark class="warning">Cookie</mark></span></a></h3><ul><li><em><strong>存储大小限制在 4KB 左右</strong></em>。</li><li><em><strong>数据会随请求发送到服务器</strong></em>，适用于维护用户会话。</li><li>可设置过期时间，<em><strong>支持持久存储</strong></em>。</li></ul><h3 id="sessionstorage" tabindex="-1"><a class="header-anchor" href="#sessionstorage"><span><mark class="warning">sessionStorage</mark></span></a></h3><ul><li>数据在浏览器窗口的会话期间存储，<em><strong>窗口关闭后自动删除</strong></em>。</li><li>存储容量通常为 5MB。</li><li>只在同一标签页中可用，<em><strong>跨标签页则不可访问</strong></em>。</li></ul><h3 id="localstorage" tabindex="-1"><a class="header-anchor" href="#localstorage"><span><mark class="warning">localStorage</mark></span></a></h3><ul><li>用于 <strong><em>长期存储数据</em></strong>，数据不会随窗口或标签页关闭而消失。</li><li>除非主动删除，数据可以无限期保持，<strong><em>通常容量为 5MB 以上</em></strong>。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>跨域问题在 web 开发中是一个常见而重要的课题。合理理解和应用各种跨域解决方案，能够帮助开发者高效地进行前后端交互。同时，熟悉用户端的存储机制以及如何合理地利用这些机制，将为构建更加安全、流畅的网络应用奠定基础。</p>',8))])}const u=n(p,[["render",m]]),k=JSON.parse('{"path":"/article/r53y5sn8/","title":"关于跨域的那些事","lang":"zh-CN","frontmatter":{"title":"关于跨域的那些事","createTime":"2025/06/24 15:05:40","permalink":"/article/r53y5sn8/","tags":["跨域","代理"],"excerpt":"面试都在问跨域，那就聊聊跨域相关的问题吧。","description":"跨域的原理 什么是跨域？ 跨域 跨域指的是当一个网页的 JavaScript 脚本请求另一个域的资源时，浏览器出于安全考虑而阻止这种行为。这种情况通常会发生在以下情况下： 协议不同，例如 HTTP 和 HTTPS 域名不同，例如 example.com 和 example.net 端口不同，例如 example.com:80 和 example.com...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"关于跨域的那些事\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-02T03:05:41.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://try-catch.life/article/r53y5sn8/"}],["meta",{"property":"og:site_name","content":"码不停蹄"}],["meta",{"property":"og:title","content":"关于跨域的那些事"}],["meta",{"property":"og:description","content":"跨域的原理 什么是跨域？ 跨域 跨域指的是当一个网页的 JavaScript 脚本请求另一个域的资源时，浏览器出于安全考虑而阻止这种行为。这种情况通常会发生在以下情况下： 协议不同，例如 HTTP 和 HTTPS 域名不同，例如 example.com 和 example.net 端口不同，例如 example.com:80 和 example.com..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-02T03:05:41.000Z"}],["meta",{"property":"article:tag","content":"代理"}],["meta",{"property":"article:tag","content":"跨域"}],["meta",{"property":"article:modified_time","content":"2025-09-02T03:05:41.000Z"}]]},"readingTime":{"minutes":3.99,"words":1196},"git":{"createdTime":1750753130000,"updatedTime":1756782341000,"contributors":[{"name":"221250108","username":"221250108","email":"221250108@smail.nju.edu.cn","commits":7,"avatar":"https://avatars.githubusercontent.com/221250108?v=4","url":"https://github.com/221250108"},{"name":"ziqingchuan","username":"ziqingchuan","email":"221250108@smail.nju.edu.cn","commits":2,"avatar":"https://avatars.githubusercontent.com/ziqingchuan?v=4","url":"https://github.com/ziqingchuan"}]},"autoDesc":true,"filePathRelative":"HTTP/关于跨域的那些事.md","headers":[],"categoryList":[{"id":"293c9e","sort":10004,"name":"HTTP"}]}');export{u as comp,k as data};
