import{_ as n,c as a,a as o,d as i,e,b as l,w as s,r as p,o as c}from"./app-5P6CFjXt.js";const d={};function g(h,t){const r=p("RouteLink");return c(),a("div",null,[t[2]||(t[2]=o('<h2 id="_1-输入-url" tabindex="-1"><a class="header-anchor" href="#_1-输入-url"><span><mark>1. 输入 URL</mark></span></a></h2><p>用户在浏览器中输入 URL（如 <code>https://www.bilibili.com</code>），浏览器会解析输入的内容，并判断其是：</p><ul><li><strong>搜索内容</strong>：将内容提交给默认搜索引擎。</li><li><strong>有效 URL</strong>：进入下一步处理流程，如果缺少协议（如 <code>http://</code> 或 <code>https://</code>），浏览器会自动补全。</li></ul><blockquote><p>💡 <strong>提示</strong>：浏览器会根据用户的历史记录和设置，智能推荐 URL 或搜索结果。</p></blockquote><h2 id="_2-查找缓存" tabindex="-1"><a class="header-anchor" href="#_2-查找缓存"><span><mark>2. 查找缓存</mark></span></a></h2><p>浏览器在向服务器发起请求前，会尝试从缓存中找到对应的页面资源，以提高加载速度并减少不必要的网络请求。缓存的查找顺序如下：</p><ul><li><p><strong>浏览器缓存：</strong> 浏览器会首先查看自身的 DNS 缓存，尝试找到对应的记录。</p></li><li><p><strong>操作系统缓存：</strong> 如果浏览器缓存中没有找到，操作系统会尝试从其 DNS 缓存中查找。</p></li><li><p><strong>路由器缓存：</strong> 如果操作系统缓存中也没有记录，请求会被发送到路由器，查看其 DNS 缓存。</p></li><li><p><strong>ISP 缓存：</strong> 如果前面都未找到记录，请求会被发送到 ISP（互联网服务提供商）的 DNS 缓存。</p></li></ul>',7)),i("p",null,[t[1]||(t[1]=e("-> ",-1)),l(r,{to:"/HTTP/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.html"},{default:s(()=>t[0]||(t[0]=[e("强制缓存与协商缓存",-1)])),_:1,__:[0]})]),t[3]||(t[3]=o('<blockquote><p>⚠️ <strong>注意</strong>：如果所有缓存查找均失败，则进入下一步：DNS 域名解析。</p></blockquote><h2 id="_3-dns-域名解析" tabindex="-1"><a class="header-anchor" href="#_3-dns-域名解析"><span><mark>3. DNS 域名解析</mark></span></a></h2><p>浏览器需要将输入的域名（如 <code>www.bilibili.com</code>）解析为对应的 IP 地址。DNS 域名解析的过程如下：</p><ul><li><p><strong>浏览器发起 DNS 请求</strong>： 浏览器向 DNS 服务器发起请求，通常是基于 UDP 协议完成。</p></li><li><p><strong>递归查询和迭代查询</strong>： DNS 服务器可能会递归查询或迭代查询，逐级解析域名，最终获取到对应的 IP 地址。</p></li><li><p><strong>返回 IP 地址</strong>： DNS 服务器将解析得到的 IP 地址返回给浏览器，供后续通信使用。</p></li></ul><blockquote><p>🌐 <strong>扩展</strong>：递归查询是由 DNS 服务器全程负责完成，迭代查询则是由客户端逐步向 DNS 服务器请求。</p></blockquote><h2 id="_4-建立-tcp-连接" tabindex="-1"><a class="header-anchor" href="#_4-建立-tcp-连接"><span><mark>4. 建立 TCP 连接</mark></span></a></h2><p>浏览器通过解析得到的 IP 地址，向目标服务器的默认端口（HTTP 为 80，HTTPS 为 443）发起 TCP 连接。TCP 连接的建立需要经过以下三次握手：</p><ul><li><p><strong>客户端发送 SYN</strong>：<br> 浏览器向服务器发送一个 SYN（同步）包，请求建立连接。</p></li><li><p><strong>服务器返回 SYN-ACK</strong>：<br> 服务器响应客户端的请求，返回一个 SYN-ACK（同步-确认）包。</p></li><li><p><strong>客户端发送 ACK</strong>：<br> 浏览器向服务器发送一个 ACK（确认）包，连接建立完成。</p></li></ul><blockquote><p>🔒 <strong>HTTPS 特殊处理</strong>：如果是 HTTPS，还需要进行 SSL/TLS 握手，以确保通信加密。</p></blockquote><h2 id="_5-发起-http-https-请求" tabindex="-1"><a class="header-anchor" href="#_5-发起-http-https-请求"><span><mark>5. 发起 HTTP/HTTPS 请求</mark></span></a></h2><p>TCP 连接建立后，浏览器会通过 HTTP 或 HTTPS 协议向服务器发送请求报文。请求报文的结构包括：</p><ul><li><strong>请求方法</strong>（如 <code>GET</code>、<code>POST</code> 等）。</li><li><strong>请求路径</strong>（如 <code>/index.html</code>）。</li><li><strong>请求头</strong>（如 <code>User-Agent</code>、<code>Accept</code>）。</li><li><strong>请求体</strong>（若有，如表单数据）。</li></ul><blockquote><p>⚙️ <strong>优化实践</strong>：使用 HTTP/2 或 HTTP/3 可以显著提升请求的并发和性能。</p></blockquote><h2 id="_6-服务器响应请求并返回结果" tabindex="-1"><a class="header-anchor" href="#_6-服务器响应请求并返回结果"><span><mark>6. 服务器响应请求并返回结果</mark></span></a></h2><p>服务器接收到请求后，会根据请求内容做出响应，返回 HTTP 响应报文。响应报文包含：</p><ul><li><strong>状态码</strong>：如 <code>200 OK</code>（成功）、<code>404 Not Found</code>（未找到）、<code>500 Internal Server Error</code>（服务器错误）。</li><li><strong>响应头</strong>：如 <code>Content-Type</code>（内容类型）、<code>Cache-Control</code>（缓存控制策略）。</li><li><strong>响应体</strong>：如 HTML 文件、JSON 数据或其他资源。</li></ul><h2 id="_7-关闭-tcp-连接" tabindex="-1"><a class="header-anchor" href="#_7-关闭-tcp-连接"><span><mark>7. 关闭 TCP 连接</mark></span></a></h2><p>浏览器与服务器之间的数据传输完成后，将通过 <strong>TCP 四次挥手</strong>关闭连接：</p><ul><li>客户端发送 FIN（结束）包，表示不再发送数据。</li><li>服务器返回 ACK（确认）包，表示收到请求。</li><li>服务器发送 FIN 包，表示不再发送数据。</li><li>客户端返回 ACK 包，连接关闭。</li></ul><blockquote><p>🛠 <strong>优化机制</strong>：现代协议（如 HTTP/2 和 HTTP/3）支持连接复用，减少握手和挥手的开销。</p></blockquote><h2 id="_8-浏览器渲染页面" tabindex="-1"><a class="header-anchor" href="#_8-浏览器渲染页面"><span><mark>8. 浏览器渲染页面</mark></span></a></h2><p>浏览器接收到 HTML 文件后，会将内容解析并渲染成用户可以看到的界面。渲染过程如下：</p><ul><li><p><strong>构建 DOM 树</strong> 浏览器解析 HTML 文件，生成 DOM 树（Document Object Model）。DOM 是由 HTML 元素及其属性节点组成的树结构。</p></li><li><p><strong>构建 CSSOM 树</strong> 浏览器解析 CSS 文件或内联样式，生成 CSSOM（CSS Object Model）树。</p></li><li><p><strong>构建渲染树</strong> 浏览器将 DOM 树与 CSSOM 树结合，生成渲染树（Render Tree）。渲染树包含页面中需要显示的元素及其样式信息。</p></li><li><p><strong>布局（Layout）</strong> 浏览器根据渲染树计算每个元素在屏幕中的位置和大小。这个过程也被称为“回流”。</p></li><li><p><strong>绘制（Painting）</strong> 浏览器遍历渲染树，将每个节点绘制到屏幕上。</p></li></ul><blockquote><p>🎨 <strong>性能优化</strong>：减少 DOM 节点和重绘/回流的次数，可以显著提升页面渲染速度。</p></blockquote><h2 id="_9-其他优化机制" tabindex="-1"><a class="header-anchor" href="#_9-其他优化机制"><span><mark>9. 其他优化机制</mark></span></a></h2><ul><li><p><strong>缓存机制</strong> 浏览器会根据 HTTP 响应头中的缓存策略（如 <code>Cache-Control</code>、<code>ETag</code>）决定是否缓存资源，以减少重复请求。</p></li><li><p><strong>预加载与预解析</strong> 浏览器可能在页面加载过程中预加载资源（如图片、脚本），或对 HTML 文件进行预解析，以提升加载速度。</p></li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><mark>总结</mark></span></a></h2><p>从用户输入 URL 到页面加载完成，浏览器经历了以下主要步骤：</p><ol><li>输入 URL</li><li>查找缓存</li><li>DNS 域名解析</li><li>建立 TCP 连接</li><li>发起 HTTP/HTTPS 请求</li><li>服务器返回响应</li><li>关闭 TCP 连接</li><li>浏览器渲染页面</li></ol><blockquote><p>🚀 <strong>小贴士</strong>：通过启用 HTTP/2、压缩资源、优化缓存策略等方式，可以显著提升页面加载性能！</p></blockquote>',30))])}const u=n(d,[["render",g]]),T=JSON.parse('{"path":"/article/wy4j7brl/","title":"浏览器输入 URL 到加载页面的过程","lang":"zh-CN","frontmatter":{"title":"浏览器输入 URL 到加载页面的过程","createTime":"2025/06/24 15:06:25","permalink":"/article/wy4j7brl/","tags":["浏览器","域名解析"],"excerpt":"当我们在浏览器中输入一个 URL 并按下回车键时，背后会发生哪些操作呢？来看一下吧！","description":"1. 输入 URL 用户在浏览器中输入 URL（如 https://www.bilibili.com），浏览器会解析输入的内容，并判断其是： 搜索内容：将内容提交给默认搜索引擎。 有效 URL：进入下一步处理流程，如果缺少协议（如 http:// 或 https://），浏览器会自动补全。 💡 提示：浏览器会根据用户的历史记录和设置，智能推荐 URL...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浏览器输入 URL 到加载页面的过程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-01T02:49:49.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://try-catch.life/article/wy4j7brl/"}],["meta",{"property":"og:site_name","content":"码不停蹄"}],["meta",{"property":"og:title","content":"浏览器输入 URL 到加载页面的过程"}],["meta",{"property":"og:description","content":"1. 输入 URL 用户在浏览器中输入 URL（如 https://www.bilibili.com），浏览器会解析输入的内容，并判断其是： 搜索内容：将内容提交给默认搜索引擎。 有效 URL：进入下一步处理流程，如果缺少协议（如 http:// 或 https://），浏览器会自动补全。 💡 提示：浏览器会根据用户的历史记录和设置，智能推荐 URL..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-01T02:49:49.000Z"}],["meta",{"property":"article:tag","content":"域名解析"}],["meta",{"property":"article:tag","content":"浏览器"}],["meta",{"property":"article:modified_time","content":"2025-09-01T02:49:49.000Z"}]]},"readingTime":{"minutes":5.03,"words":1509},"git":{"createdTime":1750753130000,"updatedTime":1756694989000,"contributors":[{"name":"221250108","username":"221250108","email":"221250108@smail.nju.edu.cn","commits":7,"avatar":"https://avatars.githubusercontent.com/221250108?v=4","url":"https://github.com/221250108"},{"name":"ziqingchuan","username":"ziqingchuan","email":"221250108@smail.nju.edu.cn","commits":1,"avatar":"https://avatars.githubusercontent.com/ziqingchuan?v=4","url":"https://github.com/ziqingchuan"}]},"autoDesc":true,"filePathRelative":"前端开发/浏览器输入url到加载页面的过程.md","headers":[],"categoryList":[{"id":"0ffed7","sort":10005,"name":"前端开发"}]}');export{u as comp,T as data};
