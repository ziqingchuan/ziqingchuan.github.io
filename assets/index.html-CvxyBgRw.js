import{_ as r,c as h,a,b as s,e as n,d as t,w as o,r as e,o as k}from"./app-Jqp_sILR.js";const g={};function d(c,i){const p=e("Badge"),l=e("RouteLink");return k(),h("div",null,[i[7]||(i[7]=a('<h2 id="什么是闭包" tabindex="-1"><a class="header-anchor" href="#什么是闭包"><span>什么是闭包？</span></a></h2><p>闭包的定义可以从不同角度描述：</p><div class="hint-container warning"><p class="hint-container-title"><strong>基本定义</strong></p><p>闭包是指<mark>一个函数能够记住其定义时的作用域，即使在函数执行完毕后，其作用域依然存在</mark>。</p><p>具体来说，闭包是由函数和其外部环境（即作用域）组成的组合。</p></div><div class="hint-container tip"><p class="hint-container-title"><strong>通俗理解</strong></p><p>当一个函数“记住”了它在创建时的作用域环境，并能在它执行时继续访问这个作用域中的变量时，就形成了闭包。</p></div><h2 id="闭包的特性" tabindex="-1"><a class="header-anchor" href="#闭包的特性"><span>闭包的特性</span></a></h2><p>闭包有以下几个显著特性：</p><ol><li><p><mark class="note"><strong>作用域链的向上查找</strong></mark></p><p>闭包会通过作用域链访问其外部函数的变量。即使外部函数已经执行完毕，闭包依然能够访问这些变量。</p></li><li><p><mark class="note"><strong>延长变量的生命周期</strong></mark></p><p>通常情况下，函数执行完毕后，其作用域会被销毁。但闭包会将外部函数的作用域保存在内存中，延长了这些变量的生命周期。</p></li><li><p><mark class="note"><strong>函数嵌套</strong></mark></p><p>闭包的本质是函数嵌套，内部函数可以访问外部函数的变量，而外部函数无法访问内部函数的变量。</p></li><li><p><mark class="note"><strong>数据存储容器</strong></mark></p><p>闭包可以看作是一种存储数据的容器，类似于 <code>Map</code> 或 <code>Set</code>，其内部以 key-value 的形式存储变量。</p></li><li><p><mark class="note"><strong>保护作用</strong></mark></p><p>闭包可以隔离数据，将外部访问限制在特定的范围内，从而实现对变量的保护。</p></li></ol><h2 id="闭包的形成条件" tabindex="-1"><a class="header-anchor" href="#闭包的形成条件"><span>闭包的形成条件</span></a></h2><p>闭包的形成需要满足以下两个条件：</p>',9)),s("ol",null,[s("li",null,[s("p",null,[s("strong",null,[n(p,{text:"函数嵌套",type:"warning"})])])]),s("li",null,[s("p",null,[s("strong",null,[n(p,{text:"内部函数引用外部函数的变量",type:"tip"})])])])]),i[8]||(i[8]=a(`<p>代码示例：</p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark has-highlighted vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> outerFunction</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  let </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 外部函数的局部变量</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  function</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> innerFunction</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line highlighted"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    count</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 内部函数引用了外部函数的变量</span></span>
<span class="line highlighted"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line highlighted"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> innerFunction</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 将内部函数返回，形成闭包</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">closure</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> outerFunction</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 执行外部函数，获取内部函数的引用</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">closure</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 输出 1</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">closure</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 输出 2</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">closure</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 输出 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="闭包的作用" tabindex="-1"><a class="header-anchor" href="#闭包的作用"><span>闭包的作用</span></a></h2><p>闭包在 JavaScript 中的作用主要体现在以下两个方面：</p><ol><li><p><mark class="important"><strong>保护（隔离）</strong></mark></p><p>闭包可以<em><strong>保护函数内部的变量不受外界干扰</strong></em>，形成一个私有的作用域。外部无法直接修改这些变量，只能通过闭包提供的接口进行操作。</p><p>例如：在模块化开发中，闭包可以用来封装私有变量和方法，避免全局变量污染。</p></li><li><p><mark class="important"><strong>保存（记忆）</strong></mark></p><p>闭包可以<em><strong>延长变量的生命周期</strong></em>，将某些变量保存在内存中，供后续使用。这种特性非常适合需要持久化数据的场景。</p></li></ol><h2 id="闭包的优点" tabindex="-1"><a class="header-anchor" href="#闭包的优点"><span>闭包的优点</span></a></h2><ol><li><p><mark class="tip"><strong>延长局部变量的生命周期</strong></mark></p><p>通常情况下，函数运行结束后其局部变量会被销毁。但 <strong><em>通过闭包，这些变量可以长期存储在内存中</em></strong>。</p></li><li><p><mark class="tip"><strong>数据封装</strong></mark></p><p><strong><em>闭包实现了对变量的私有化保护</em></strong>，可以有效避免全局变量污染，使代码更加模块化和安全。</p></li><li><p><mark class="tip"><strong>简化逻辑</strong></mark></p><p>闭包可以通过 <strong><em>保存中间状态</em></strong>，简化复杂逻辑的实现。例如，事件处理函数可以记住初始状态，避免重复计算。</p></li><li><p><mark class="tip"><strong>增强函数的灵活性</strong></mark></p><p>闭包使得函数可以 <strong><em>动态生成不同的逻辑</em></strong>，从而提高代码的复用性和可维护性。</p></li></ol><h2 id="闭包的缺点" tabindex="-1"><a class="header-anchor" href="#闭包的缺点"><span>闭包的缺点</span></a></h2><ol><li><p><mark class="caution"><strong>内存占用</strong></mark></p><p>由于闭包会保存外部函数的作用域，可能导致内存占用增加。如果闭包被频繁创建或者不及时释放，<strong><em>可能会引发内存泄漏</em></strong>。</p></li><li><p><mark class="caution"><strong>性能开销</strong></mark></p><p>JavaScript 的垃圾回收机制通常会释放不再使用的变量，但 <strong><em>闭包会延长变量的生命周期</em></strong>，增加了垃圾回收的负担。</p></li><li><p><mark class="caution"><strong>代码复杂性增加</strong></mark></p><p>过度使用闭包可能导致代码的可读性和维护性下降，<em><strong>尤其是在嵌套过深时</strong></em>。</p></li></ol><h2 id="闭包的应用场景" tabindex="-1"><a class="header-anchor" href="#闭包的应用场景"><span>闭包的应用场景</span></a></h2><p>闭包在 JavaScript 的开发中应用非常广泛，以下是一些常见的场景：</p>`,11)),s("ol",null,[i[5]||(i[5]=a("<li><p><mark><strong>事件处理</strong></mark></p><p>闭包可以存储事件处理函数执行时的上下文信息。例如，在绑定事件时，闭包可以记住初始状态，从而实现动态行为。</p></li><li><p><mark><strong>回调函数</strong></mark></p><p>在异步操作中，例如定时器、网络请求、Promise 等，闭包可以保存函数执行时的状态和变量。</p></li><li><p><mark><strong>数据封装</strong></mark></p><p>闭包可以用来创建模块化代码，通过定义私有变量和方法，限制外部对数据的直接访问。例如，计数器、缓存等功能常通过闭包实现。</p></li><li><p><mark><strong>模拟块级作用域</strong></mark></p><p>在没有 <code>let</code> 和 <code>const</code> 的时代，通过闭包可以模拟块级作用域，避免变量污染全局作用域。</p></li>",4)),s("li",null,[i[3]||(i[3]=s("p",null,[s("mark",null,[s("strong",null,"函数柯里化")])],-1)),s("p",null,[s("em",null,[s("strong",null,[i[1]||(i[1]=t("（什么是函数柯里化？ → ")),n(l,{to:"/JavaScript/js%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96.html"},{default:o(()=>i[0]||(i[0]=[t("js中的函数柯里化")])),_:1,__:[0]}),i[2]||(i[2]=t("）"))])])]),i[4]||(i[4]=s("p",null,"闭包是实现柯里化的关键。柯里化函数通过闭包保存部分参数，从而生成新的函数。",-1))]),i[6]||(i[6]=s("li",null,[s("p",null,[s("mark",null,[s("strong",null,"惰性函数")])]),s("p",null,"闭包可以用来创建惰性函数，在需要时延迟执行代码，从而提高性能。")],-1))]),i[9]||(i[9]=a('<h2 id="闭包的注意事项" tabindex="-1"><a class="header-anchor" href="#闭包的注意事项"><span>闭包的注意事项</span></a></h2><div class="hint-container warning"><p class="hint-container-title">注意</p><p><strong>合理使用闭包</strong></p><p>虽然闭包功能强大，但滥用闭包可能导致代码复杂度增加或性能问题。在性能敏感的场景中，应谨慎使用闭包。</p><p><strong>避免内存泄漏</strong></p><p>闭包会导致外部函数的作用域无法被释放，因此需要避免不必要的闭包引用。例如，不要在全局变量中保存闭包函数。</p><p><strong>调试困难</strong></p><p>由于闭包会保留创建时的作用域，调试时可能难以直观地理解变量的来源。因此，代码中应适当添加注释，帮助理解闭包的行为。</p></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>闭包是 JavaScript 中非常重要的特性，它通过保存外部函数的作用域，实现了对变量的保护和保存。闭包的应用场景广泛，从事件处理到数据封装，从函数柯里化到模块化开发，几乎无处不在。然而，闭包的使用也需要注意内存管理和代码复杂性的控制。掌握闭包的原理和应用技巧，是成为高级 JavaScript 开发者的必备技能。</p>',4))])}const u=r(g,[["render",d]]),y=JSON.parse('{"path":"/article/eagyikza/","title":"🐳浅谈js中的闭包","lang":"zh-CN","frontmatter":{"title":"🐳浅谈js中的闭包","createTime":"2025/06/25 16:41:37","permalink":"/article/eagyikza/","tags":["JavaScript","闭包"],"excerpt":"从定义、特性、形成条件、作用、优缺点及应用场景等多个方面谈谈闭包。","description":"什么是闭包？ 闭包的定义可以从不同角度描述： 基本定义 闭包是指一个函数能够记住其定义时的作用域，即使在函数执行完毕后，其作用域依然存在。 具体来说，闭包是由函数和其外部环境（即作用域）组成的组合。 通俗理解 当一个函数“记住”了它在创建时的作用域环境，并能在它执行时继续访问这个作用域中的变量时，就形成了闭包。 闭包的特性 闭包有以下几个显著特性： 作...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"🐳浅谈js中的闭包\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-25T14:47:52.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://try-catch.life/article/eagyikza/"}],["meta",{"property":"og:site_name","content":"码不停蹄"}],["meta",{"property":"og:title","content":"🐳浅谈js中的闭包"}],["meta",{"property":"og:description","content":"什么是闭包？ 闭包的定义可以从不同角度描述： 基本定义 闭包是指一个函数能够记住其定义时的作用域，即使在函数执行完毕后，其作用域依然存在。 具体来说，闭包是由函数和其外部环境（即作用域）组成的组合。 通俗理解 当一个函数“记住”了它在创建时的作用域环境，并能在它执行时继续访问这个作用域中的变量时，就形成了闭包。 闭包的特性 闭包有以下几个显著特性： 作..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-25T14:47:52.000Z"}],["meta",{"property":"article:tag","content":"闭包"}],["meta",{"property":"article:tag","content":"JavaScript"}],["meta",{"property":"article:modified_time","content":"2025-06-25T14:47:52.000Z"}]]},"readingTime":{"minutes":5.82,"words":1745},"git":{"createdTime":1750843915000,"updatedTime":1750862872000,"contributors":[{"name":"221250108","username":"221250108","email":"221250108@smail.nju.edu.cn","commits":4,"avatar":"https://avatars.githubusercontent.com/221250108?v=4","url":"https://github.com/221250108"}]},"autoDesc":true,"filePathRelative":"JavaScript/浅谈js中的闭包.md","headers":[],"categoryList":[{"id":"686155","sort":10002,"name":"JavaScript"}]}');export{u as comp,y as data};
