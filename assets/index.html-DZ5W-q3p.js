import{_ as o,c as i,a,o as t}from"./app-BQ4NqVzy.js";const l={};function c(d,e){return t(),i("div",null,e[0]||(e[0]=[a('<h2 id="强制缓存" tabindex="-1"><a class="header-anchor" href="#强制缓存"><span>强制缓存</span></a></h2><p><mark>强制缓存是浏览器在请求资源时首先检查的缓存机制</mark>。</p><h3 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h3><ol><li>浏览器发起请求时，首先检查本地缓存</li><li>如果缓存存在且未过期，直接使用缓存资源</li><li>如果缓存不存在或已过期，才向服务器发起请求</li></ol><h3 id="控制字段" tabindex="-1"><a class="header-anchor" href="#控制字段"><span>控制字段</span></a></h3><p>强制缓存由两个主要的HTTP头部控制：</p><ol><li><p><strong><code>Expires</code></strong></p><ul><li>HTTP/1.0的缓存控制字段</li><li>值为一个绝对时间（如<code>Expires: Wed, 21 Oct 2025 07:28:00 GMT</code>）</li><li>缺点：依赖客户端本地时间，如果用户修改了系统时间，可能导致缓存失效</li></ul></li><li><p><strong><code>Cache-Control</code></strong></p><ul><li><p>HTTP/1.1引入的更强大的缓存控制字段</p></li><li><p>常用指令：</p><ul><li><code>max-age=</code>：设置缓存的最大生命周期（秒）</li><li><code>no-cache</code>：不使用强制缓存，直接进入协商缓存</li><li><code>no-store</code>：完全不使用任何缓存</li><li><code>public</code>：响应可以被任何中间节点缓存</li><li><code>private</code>：响应只能被浏览器缓存</li></ul></li><li><p>示例：<code>Cache-Control: max-age=31536000</code></p></li></ul></li></ol><p><strong>优先级</strong>：当<code>Cache-Control</code>和<code>Expires</code>同时存在时，<code>Cache-Control</code>的优先级更高。</p><h3 id="强制缓存的三种情况" tabindex="-1"><a class="header-anchor" href="#强制缓存的三种情况"><span>强制缓存的三种情况</span></a></h3><ol><li><strong>缓存不存在</strong>：直接向服务器发起请求（如同第一次请求）</li><li><strong>缓存存在但已过期</strong>：强制缓存失效，进入协商缓存阶段</li><li><strong>缓存存在且未过期</strong>：直接使用缓存，状态码200，但显示<code>from cache</code></li></ol><h2 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存"><span>协商缓存</span></a></h2><p><mark>当强制缓存失效时，浏览器会进入协商缓存阶段</mark>。</p><h3 id="工作原理-1" tabindex="-1"><a class="header-anchor" href="#工作原理-1"><span>工作原理</span></a></h3><ol><li>浏览器携带缓存标识向服务器发起请求</li><li>服务器根据标识判断资源是否变化</li><li>如果未变化，返回<code>304 Not Modified</code>，浏览器使用本地缓存</li><li>如果已变化，返回200和新资源</li></ol><h3 id="控制字段-1" tabindex="-1"><a class="header-anchor" href="#控制字段-1"><span>控制字段</span></a></h3><p>协商缓存有两组控制字段：</p><ol><li><p><strong><code>Last-Modified / If-Modified-Since</code></strong></p><ul><li>服务器在首次响应时返回<code>Last-Modified</code>头部，表示资源最后修改时间</li><li>浏览器再次请求时，在<code>If-Modified-Since</code>头部带上这个时间</li><li>服务器比较当前资源修改时间和<code>If-Modified-Since</code>值</li><li>缺点：精度只到秒级，可能因文件内容未变但修改时间变化导致不必要的请求</li></ul></li><li><p><strong><code>ETag / If-None-Match</code></strong></p><ul><li>服务器在首次响应时返回<code>ETag</code>头部，是资源的唯一标识符（通常是内容的哈希值）</li><li>浏览器再次请求时，在<code>If-None-Match</code>头部带上这个ETag值</li><li>服务器比较当前资源ETag和<code>If-None-Match</code>值</li><li>更精确，能感知内容变化</li></ul></li></ol><p><strong>优先级</strong>：当<code>ETag</code>和<code>Last-Modified</code>同时存在时，<code>ETag</code>的优先级更高。</p><h3 id="协商缓存的两种情况" tabindex="-1"><a class="header-anchor" href="#协商缓存的两种情况"><span>协商缓存的两种情况</span></a></h3><ol><li><strong>缓存有效</strong>：返回<code>304 Not Modified</code>，浏览器使用本地缓存</li><li><strong>缓存无效</strong>：返回200和新资源</li></ol><h2 id="缓存流程总结" tabindex="-1"><a class="header-anchor" href="#缓存流程总结"><span>缓存流程总结</span></a></h2><ol><li><p>浏览器发起请求时，先检查强制缓存</p><ul><li>如果缓存有效且未过期，直接使用缓存</li><li>如果缓存不存在或已过期，进入协商缓存阶段</li></ul></li><li><p>协商缓存阶段：</p><ul><li>浏览器发送请求，携带<code>If-None-Match</code>(ETag)和/或<code>If-Modified-Since</code>(Last-Modified)</li><li>服务器验证资源是否变化 <ul><li>未变化：返回304，浏览器使用缓存</li><li>已变化：返回200和新资源</li></ul></li></ul></li><li><p>新资源会被浏览器缓存，并更新缓存标识</p></li></ol><h2 id="实际应用建议" tabindex="-1"><a class="header-anchor" href="#实际应用建议"><span>实际应用建议</span></a></h2><ul><li>对于静态资源（如JS、CSS、图片）：设置较长的<code>max-age</code>（如1年），并使用内容哈希作为文件名或查询参数，这样可以在内容变化时自动失效缓存</li><li>对于频繁变化的资源：使用<code>no-cache</code>或较短的<code>max-age</code>，依赖协商缓存</li><li>对于敏感数据：使用<code>no-store</code>确保不缓存</li></ul><p>通过合理配置缓存策略，可以显著提高网站性能，减少服务器负载，提升用户体验。</p>',25)]))}const n=o(l,[["render",c]]),s=JSON.parse('{"path":"/article/eb2rw5pv/","title":"强制缓存与协商缓存","lang":"zh-CN","frontmatter":{"title":"强制缓存与协商缓存","createTime":"2025/07/12 10:07:27","permalink":"/article/eb2rw5pv/","tags":["缓存","HTTP"],"excerpt":"强制缓存与协商缓存是浏览器缓存的两种机制，可以减少不必要的网络请求，加快页面加载速度","description":"强制缓存 强制缓存是浏览器在请求资源时首先检查的缓存机制。 工作原理 浏览器发起请求时，首先检查本地缓存 如果缓存存在且未过期，直接使用缓存资源 如果缓存不存在或已过期，才向服务器发起请求 控制字段 强制缓存由两个主要的HTTP头部控制： Expires HTTP/1.0的缓存控制字段 值为一个绝对时间（如Expires: Wed, 21 Oct 20...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"强制缓存与协商缓存\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-12T11:41:17.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://try-catch.life/article/eb2rw5pv/"}],["meta",{"property":"og:site_name","content":"码不停蹄"}],["meta",{"property":"og:title","content":"强制缓存与协商缓存"}],["meta",{"property":"og:description","content":"强制缓存 强制缓存是浏览器在请求资源时首先检查的缓存机制。 工作原理 浏览器发起请求时，首先检查本地缓存 如果缓存存在且未过期，直接使用缓存资源 如果缓存不存在或已过期，才向服务器发起请求 控制字段 强制缓存由两个主要的HTTP头部控制： Expires HTTP/1.0的缓存控制字段 值为一个绝对时间（如Expires: Wed, 21 Oct 20..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-12T11:41:17.000Z"}],["meta",{"property":"article:tag","content":"HTTP"}],["meta",{"property":"article:tag","content":"缓存"}],["meta",{"property":"article:modified_time","content":"2025-07-12T11:41:17.000Z"}]]},"readingTime":{"minutes":3.49,"words":1047},"git":{"createdTime":1750753130000,"updatedTime":1752320477000,"contributors":[{"name":"221250108","username":"221250108","email":"221250108@smail.nju.edu.cn","commits":4,"avatar":"https://avatars.githubusercontent.com/221250108?v=4","url":"https://github.com/221250108"}]},"autoDesc":true,"filePathRelative":"HTTP/强制缓存与协商缓存.md","headers":[],"categoryList":[{"id":"293c9e","sort":10002,"name":"HTTP"}]}');export{n as comp,s as data};
