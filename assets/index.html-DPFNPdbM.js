import{_ as s,c as a,a as t,o as e}from"./app-dBN3hkz1.js";const n={};function l(h,i){return e(),a("div",null,i[0]||(i[0]=[t(`<h2 id="_1-ref" tabindex="-1"><a class="header-anchor" href="#_1-ref"><span>1. <code>ref()</code></span></a></h2><h3 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法"><span>基本用法</span></a></h3><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark has-diff vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ref</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 创建响应式变量</span></span>
<span class="line diff add"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">value</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span></span>
<span class="line diff remove"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点</span></a></h3><ul><li>用于基本类型(也可用于对象)</li><li><mark>需要通过.value访问值</mark></li><li>模板中自动解包(不需.value)</li><li>适合简单响应式数据</li></ul><h2 id="_2-reactive" tabindex="-1"><a class="header-anchor" href="#_2-reactive"><span>2. <code>reactive()</code></span></a></h2><h3 id="基本用法-1" tabindex="-1"><a class="header-anchor" href="#基本用法-1"><span>基本用法</span></a></h3><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark has-diff vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">state</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> reactive</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">({</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">   count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">   name</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">John</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">})</span></span>
<span class="line diff remove"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">value</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span></span>
<span class="line diff add"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="特点-1" tabindex="-1"><a class="header-anchor" href="#特点-1"><span>特点</span></a></h3><ul><li>用于对象/数组等复杂类型</li><li><mark>不需要.value直接访问</mark></li><li>不能解构(会失去响应性)</li><li>适合<mark>复杂状态对象</mark></li></ul><h2 id="_3-computed" tabindex="-1"><a class="header-anchor" href="#_3-computed"><span>3. <code>computed()</code></span></a></h2><h3 id="基本用法-2" tabindex="-1"><a class="header-anchor" href="#基本用法-2"><span>基本用法</span></a></h3><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">doubleCount</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> computed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">value</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> * </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="特点-2" tabindex="-1"><a class="header-anchor" href="#特点-2"><span>特点</span></a></h3><ul><li>基于依赖自动计算</li><li>具有缓存(<mark>依赖不变不重新计算</mark>)</li><li>返回一个不可变的ref</li><li>适合派生状态</li></ul><h2 id="_4-watch" tabindex="-1"><a class="header-anchor" href="#_4-watch"><span>4. <code>watch()</code></span></a></h2><h3 id="基本用法-3" tabindex="-1"><a class="header-anchor" href="#基本用法-3"><span>基本用法</span></a></h3><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">watch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> state</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">newVal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> oldVal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 回调</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">\`</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">count变化: </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">\${</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">oldVal</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">}</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> -&gt; </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">\${</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">newVal</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">}</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">\`</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="特点-3" tabindex="-1"><a class="header-anchor" href="#特点-3"><span>特点</span></a></h3><ul><li>精确监听特定数据源</li><li><mark>可以获取旧值和新值</mark></li><li>需要手动指定监听源</li><li>适合需要旧值的场景</li></ul><h2 id="_5-watcheffect" tabindex="-1"><a class="header-anchor" href="#_5-watcheffect"><span>5. <code>watchEffect()</code></span></a></h2><h3 id="基本用法-4" tabindex="-1"><a class="header-anchor" href="#基本用法-4"><span>基本用法</span></a></h3><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">watchEffect</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">count值:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="特点-4" tabindex="-1"><a class="header-anchor" href="#特点-4"><span>特点</span></a></h3><ul><li>自动追踪依赖</li><li><mark>立即执行一次</mark></li><li>无法获取旧值</li><li>适合不需要旧值的场景</li></ul><h2 id="对比总结" tabindex="-1"><a class="header-anchor" href="#对比总结"><span>对比总结</span></a></h2><table><thead><tr><th style="text-align:center;">特性</th><th style="text-align:center;">ref()</th><th style="text-align:center;">reactive()</th><th style="text-align:center;">computed()</th><th style="text-align:center;">watch()</th><th style="text-align:center;">watchEffect()</th></tr></thead><tbody><tr><td style="text-align:center;">用途</td><td style="text-align:center;">基本类型响应式</td><td style="text-align:center;">对象响应式</td><td style="text-align:center;">计算属性</td><td style="text-align:center;">监听变化</td><td style="text-align:center;">自动依赖监听</td></tr><tr><td style="text-align:center;">访问方式</td><td style="text-align:center;">.value</td><td style="text-align:center;">直接访问</td><td style="text-align:center;">.value</td><td style="text-align:center;">N/A</td><td style="text-align:center;">N/A</td></tr><tr><td style="text-align:center;">缓存</td><td style="text-align:center;">无</td><td style="text-align:center;">无</td><td style="text-align:center;">有</td><td style="text-align:center;">无</td><td style="text-align:center;">无</td></tr><tr><td style="text-align:center;">立即执行</td><td style="text-align:center;">无</td><td style="text-align:center;">无</td><td style="text-align:center;">无</td><td style="text-align:center;">可配置</td><td style="text-align:center;">总是立即执行</td></tr><tr><td style="text-align:center;">主要优势</td><td style="text-align:center;">简单值响应</td><td style="text-align:center;">复杂对象响应</td><td style="text-align:center;">派生状态</td><td style="text-align:center;">精确控制监听</td><td style="text-align:center;">自动依赖收集</td></tr></tbody></table><h2 id="使用场景小结" tabindex="-1"><a class="header-anchor" href="#使用场景小结"><span>使用场景小结</span></a></h2><ol><li><strong><code>ref()</code></strong> : 基本类型数据、需要保持响应式的单个值</li><li><strong><code>reactive()</code></strong> : 复杂对象状态管理</li><li><strong><code>computed()</code></strong> : 依赖其他状态的计算属性</li><li><strong><code>watch()</code></strong> : 需要精确控制监听逻辑和获取旧值</li><li><strong><code>watchEffect()</code></strong> : 自动追踪依赖的副作用</li></ol><h2 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践"><span>最佳实践</span></a></h2><ol><li>组合式API中优先使用<code>ref()</code>和<code>reactive()</code>创建响应式状态</li><li>派生状态使用<code>computed()</code></li><li>需要执行副作用时: <ul><li>需要旧值 -&gt; <code>watch()</code></li><li>不需要旧值 -&gt; <code>watchEffect()</code></li></ul></li><li>避免在<code>reactive()</code>中使用解构</li><li>复杂逻辑可组合多个响应式API使用</li></ol>`,31)]))}const r=s(n,[["render",l]]),k=JSON.parse('{"path":"/article/5t137ky6/","title":"响应式处理函数","lang":"zh-CN","frontmatter":{"title":"响应式处理函数","tags":["前端开发","响应式函数"],"createTime":"2025/06/23 22:18:37","permalink":"/article/5t137ky6/","excerpt":"被面试官问到ref与reactive的区别，后悔当时没讲清楚，现在整理一下。","description":"1. ref() 基本用法 特点 用于基本类型(也可用于对象) 需要通过.value访问值 模板中自动解包(不需.value) 适合简单响应式数据 2. reactive() 基本用法 特点 用于对象/数组等复杂类型 不需要.value直接访问 不能解构(会失去响应性) 适合复杂状态对象 3. computed() 基本用法 特点 基于依赖自动计算 具...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"响应式处理函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-08T09:26:50.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://try-catch.life/article/5t137ky6/"}],["meta",{"property":"og:site_name","content":"码不停蹄"}],["meta",{"property":"og:title","content":"响应式处理函数"}],["meta",{"property":"og:description","content":"1. ref() 基本用法 特点 用于基本类型(也可用于对象) 需要通过.value访问值 模板中自动解包(不需.value) 适合简单响应式数据 2. reactive() 基本用法 特点 用于对象/数组等复杂类型 不需要.value直接访问 不能解构(会失去响应性) 适合复杂状态对象 3. computed() 基本用法 特点 基于依赖自动计算 具..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-08T09:26:50.000Z"}],["meta",{"property":"article:tag","content":"响应式函数"}],["meta",{"property":"article:tag","content":"前端开发"}],["meta",{"property":"article:modified_time","content":"2025-07-08T09:26:50.000Z"}]]},"readingTime":{"minutes":1.96,"words":588},"git":{"createdTime":1750691278000,"updatedTime":1751966810000,"contributors":[{"name":"221250108","username":"221250108","email":"221250108@smail.nju.edu.cn","commits":7,"avatar":"https://avatars.githubusercontent.com/221250108?v=4","url":"https://github.com/221250108"}]},"autoDesc":true,"filePathRelative":"Vue/响应式处理函数.md","headers":[],"categoryList":[{"id":"2d8ec5","sort":10000,"name":"Vue"}]}');export{r as comp,k as data};
