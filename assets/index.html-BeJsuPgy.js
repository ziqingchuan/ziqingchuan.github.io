import{_ as a,c as t,a as o,o as r}from"./app-DYwtjXTK.js";const i={};function n(l,e){return r(),t("div",null,e[0]||(e[0]=[o('<h2 id="什么是重排-reflow" tabindex="-1"><a class="header-anchor" href="#什么是重排-reflow"><span>什么是重排（Reflow）？</span></a></h2><div class="hint-container tip"><p class="hint-container-title">重排（Reflow）</p><p><strong>重排（Reflow）</strong> 是指当 <strong>DOM 的几何信息发生变化</strong> 时，浏览器需要重新计算元素的布局位置及大小，并将其放置到正确的位置。</p></div><h3 id="触发重排的场景" tabindex="-1"><a class="header-anchor" href="#触发重排的场景"><span>触发重排的场景</span></a></h3><ul><li>添加、删除或更新 DOM 节点。</li><li>改变元素的几何属性（如 <code>width</code>、<code>height</code>、<code>padding</code>、<code>margin</code>、<code>border</code> 等）。</li><li>元素的显示状态从 <code>display: none</code> 切换为可见。</li><li>浏览器窗口大小变化。</li><li>动画导致元素的几何属性变化（如移动、缩放等）。</li><li>修改字体大小或内容改变导致文本流重新计算。</li></ul><blockquote><p>💡 <strong>注意</strong>：<strong>重排是性能开销最大的操作</strong>，因为它<mark class="important">会导致整个页面或部分页面重新计算布局</mark>。</p></blockquote><h2 id="什么是重绘-repaint" tabindex="-1"><a class="header-anchor" href="#什么是重绘-repaint"><span>什么是重绘（Repaint）？</span></a></h2><div class="hint-container tip"><p class="hint-container-title">重排（Reflow）</p><p><strong>重绘（Repaint）</strong> 是指当 <strong>元素的外观发生变化</strong>（如颜色、背景、阴影等），但不影响其几何属性时，浏览器会重新绘制这些元素的外观。</p></div><h3 id="触发重绘的场景" tabindex="-1"><a class="header-anchor" href="#触发重绘的场景"><span>触发重绘的场景</span></a></h3><ul><li>改变元素的颜色（如 <code>color</code>、<code>background-color</code>）。</li><li>改变元素的边框样式（如 <code>border-color</code>）。</li><li>设置元素的透明度（如 <code>opacity</code>）。</li><li>元素的显示状态从 <code>visibility: hidden</code> 切换为可见。</li></ul><blockquote><p>⚠️ <strong>区别</strong>：重绘不影响布局，因此它的<mark class="important">性能开销通常小于重排</mark>。</p></blockquote><h2 id="重排和重绘的关系" tabindex="-1"><a class="header-anchor" href="#重排和重绘的关系"><span>重排和重绘的关系</span></a></h2><ul><li><strong>重排必然会触发重绘</strong>：因为页面布局的改变会影响元素的外观。</li><li><strong>重绘不一定会触发重排</strong>：如果仅仅是外观变化（如颜色），不会影响布局。</li></ul><blockquote><p>🚨 <strong>总结</strong>：重排的性能消耗更高，因此在开发中应尽量避免频繁触发重排操作。</p></blockquote><h2 id="如何优化避免重排与重绘" tabindex="-1"><a class="header-anchor" href="#如何优化避免重排与重绘"><span>如何优化避免重排与重绘？</span></a></h2><h3 id="_1-减少-dom-操作" tabindex="-1"><a class="header-anchor" href="#_1-减少-dom-操作"><span>1. <mark>减少 DOM 操作</mark></span></a></h3><ul><li><strong>合并多次 DOM 更新</strong>：集中修改 DOM，而不是逐条操作。</li><li><strong>离线更新 DOM</strong>：使用 <code>DocumentFragment</code> 或克隆节点在内存中操作，完成后一次性更新到 DOM 中。</li></ul><h3 id="_2-避免循环中操作-dom" tabindex="-1"><a class="header-anchor" href="#_2-避免循环中操作-dom"><span>2. <mark>避免循环中操作 DOM</mark></span></a></h3><p>将 DOM 属性值提取到变量中，在循环外部完成修改。</p><h3 id="_3-使用合适的显示属性" tabindex="-1"><a class="header-anchor" href="#_3-使用合适的显示属性"><span>3. <mark>使用合适的显示属性</mark></span></a></h3><ul><li>使用 <code>visibility: hidden</code> 代替 <code>display: none</code>，因为前者只触发重绘，而后者会触发重排。</li><li>为频繁变化的元素设置 <code>position: absolute</code> 或 <code>fixed</code>，可以减少对其他元素的影响。</li></ul><h3 id="_4-动画优化" tabindex="-1"><a class="header-anchor" href="#_4-动画优化"><span>4. <mark>动画优化</mark></span></a></h3><ul><li>使用 <code>transform</code> 和 <code>opacity</code> 来实现动画，因为它们不会触发回流或重绘。</li><li>启用 GPU 加速，通过 <code>translate3d</code> 或 <code>will-change</code> 提升性能。</li></ul><h3 id="_5-避免使用-table-布局" tabindex="-1"><a class="header-anchor" href="#_5-避免使用-table-布局"><span>5. <mark>避免使用 Table 布局</mark></span></a></h3><p>Table 的布局依赖于其子元素的几何信息，任何改动都会导致整个表格重新计算布局。</p><h3 id="_6-减少样式计算和重排" tabindex="-1"><a class="header-anchor" href="#_6-减少样式计算和重排"><span>6. <mark>减少样式计算和重排</mark></span></a></h3><ul><li>避免频繁读取会触发回流的属性（如 <code>offsetWidth</code>、<code>offsetHeight</code> 等），可以将其缓存到变量中。</li><li>使用 <code>class</code> 切换样式而不是逐条修改样式属性。</li></ul><h2 id="提升合成层的性能优化" tabindex="-1"><a class="header-anchor" href="#提升合成层的性能优化"><span>提升合成层的性能优化</span></a></h2><p><strong>合成层</strong>是浏览器单独为某些元素创建的图层，可以有效减少重排和重绘的开销。</p><h3 id="如何提升元素为合成层" tabindex="-1"><a class="header-anchor" href="#如何提升元素为合成层"><span>如何提升元素为合成层？</span></a></h3><ul><li>使用 <code>will-change</code> 属性。</li><li>使用 3D 变换（如 <code>translate3d</code>）。</li></ul><h3 id="合成层的优点" tabindex="-1"><a class="header-anchor" href="#合成层的优点"><span>合成层的优点</span></a></h3><ol><li><strong>GPU 优化</strong>：合成层的位图会交由 GPU 合成，比 CPU 处理更快。</li><li><strong>局部重绘</strong>：合成层只会重绘自身，不会影响其他层。</li><li><strong>避免回流</strong>：<code>transform</code> 和 <code>opacity</code> 等效果不会触发重排和重绘。</li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>在浏览器渲染过程中，<strong>重排和重绘是不可避免的</strong>，但可以通过优化代码减少它们的频繁触发。以下是关键点总结：</p><ol><li><strong>重排比重绘性能开销更大，应尽量减少重排操作</strong>。</li><li><strong>使用合适的优化策略</strong>：如集中修改样式、缓存属性值、使用合成层等。</li><li><strong>利用 GPU 加速和 CSS 动画</strong>，提升页面的渲染性能。</li></ol><blockquote><p>🚀 <strong>性能优化建议</strong>：减少 DOM 操作与回流重排，使用现代化的开发工具和框架（如 React 和 Vue）可以帮助开发者更高效地优化页面性能和用户体验。</p></blockquote>',36)]))}const d=a(i,[["render",n]]),s=JSON.parse('{"path":"/article/reioxd5m/","title":"重绘与重排","lang":"zh-CN","frontmatter":{"title":"重绘与重排","createTime":"2025/06/24 15:03:23","permalink":"/article/reioxd5m/","tags":["重绘&重排","浏览器","前端开发"],"excerpt":"被面试官问到面红耳赤说不明白，今天静下心回顾一下这两个概念。","description":"什么是重排（Reflow）？ 重排（Reflow） 重排（Reflow） 是指当 DOM 的几何信息发生变化 时，浏览器需要重新计算元素的布局位置及大小，并将其放置到正确的位置。 触发重排的场景 添加、删除或更新 DOM 节点。 改变元素的几何属性（如 width、height、padding、margin、border 等）。 元素的显示状态从 di...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"重绘与重排\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-01T16:52:49.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://try-catch.life/article/reioxd5m/"}],["meta",{"property":"og:site_name","content":"码不停蹄"}],["meta",{"property":"og:title","content":"重绘与重排"}],["meta",{"property":"og:description","content":"什么是重排（Reflow）？ 重排（Reflow） 重排（Reflow） 是指当 DOM 的几何信息发生变化 时，浏览器需要重新计算元素的布局位置及大小，并将其放置到正确的位置。 触发重排的场景 添加、删除或更新 DOM 节点。 改变元素的几何属性（如 width、height、padding、margin、border 等）。 元素的显示状态从 di..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-01T16:52:49.000Z"}],["meta",{"property":"article:tag","content":"前端开发"}],["meta",{"property":"article:tag","content":"浏览器"}],["meta",{"property":"article:tag","content":"重绘&重排"}],["meta",{"property":"article:modified_time","content":"2025-07-01T16:52:49.000Z"}]]},"readingTime":{"minutes":3.58,"words":1075},"git":{"createdTime":1750753130000,"updatedTime":1751388769000,"contributors":[{"name":"221250108","username":"221250108","email":"221250108@smail.nju.edu.cn","commits":7,"avatar":"https://avatars.githubusercontent.com/221250108?v=4","url":"https://github.com/221250108"}]},"autoDesc":true,"filePathRelative":"前端开发/重绘与重排.md","headers":[],"categoryList":[{"id":"0ffed7","sort":10000,"name":"前端开发"}]}');export{d as comp,s as data};
